<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
    <title>api-headers-form test</title>
    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <link rel="import" href="../api-headers-form-item.html">
    <link rel="import" href="../../arc-polyfills/arc-polyfills.html">
  </head>
  <body>

    <test-fixture id="Basic">
      <template>
        <api-headers-form-item name="test-name" value="test-value"></api-headers-form-item>
      </template>
    </test-fixture>

    <test-fixture id="Required">
      <template>
        <api-headers-form-item name="test-name" required></api-headers-form-item>
      </template>
    </test-fixture>

    <test-fixture id="Custom">
      <template>
        <api-headers-form-item name="test-name" value="test-value" is-custom></api-headers-form-item>
      </template>
    </test-fixture>

    <test-fixture id="Narrow">
      <template>
        <api-headers-form-item name="test-name" value="test-value" narrow></api-headers-form-item>
      </template>
    </test-fixture>

    <test-fixture id="NoDocs">
      <template>
        <api-headers-form-item name="Content-type" value="test-value" no-docs></api-headers-form-item>
      </template>
    </test-fixture>

    <script>
    suite('api-headers-form-item', () => {
      function genModel(name) {
        name = name || 'test-name';
        return {
          binding: 'header',
          name: name,
          hasDescription: true,
          description: 'test',
          required: true,
          schema: {
            enabled: true,
            type: 'string',
            inputLabel: 'x-string',
            isEnum: false,
            isArray: false,
            isBool: false,
            inputType: 'text'
          },
          value: 'test-value'
        };
      }


      suite('Basic tests', function() {
        let element;
        setup(function(done) {
          element = fixture('Basic');
          element.model = genModel();
          flush(() => done());
        });

        test('Renders form field for API defined item', () => {
          const node = element.shadowRoot.querySelector('.api-field');
          assert.ok(node);
        });

        test('Renders documentation toggle icon', () => {
          const node = element.shadowRoot.querySelector('.hint-icon');
          assert.ok(node);
        });

        test('Renders docs section', (done) => {
          element.toggleDocs();
          flush(() => {
            const node = element.shadowRoot.querySelector('.docs');
            assert.ok(node);
            done();
          });
        });

        test('Sets _valueInput on input focus', function() {
          element._customChangeFocus();
          const input = element.shadowRoot.querySelector('api-property-form-item');
          // input.focus();
          assert.isTrue(element._valueInput === input);
        });

        test('Sets __customChangeFocus on input focus', function() {
          element._customChangeFocus();
          assert.isTrue(element.__customChangeFocus);
        });
      });

      suite('Required', function() {
        let element;
        setup(function() {
          element = fixture('Required');
          const m = genModel();
          m.value = '';
          element.model = m;
        });

        test('Does not validate the in put', (done) => {
          flush(() => {
            const result = element.validate();
            assert.isFalse(result);
            done();
          });
        });

        test('Sets invalid property', (done) => {
          flush(() => {
            element.validate();
            assert.isTrue(element.invalid);
            done();
          });
        });
      });

      suite('Custom value', () => {
        let element;
        setup(function(done) {
          element = fixture('Custom');
          element.model = genModel();
          flush(() => done());
        });

        test('Renders custom section', () => {
          const node = element.shadowRoot.querySelector('.custom-wrapper');
          assert.ok(node);
        });

        test('Renders name input', () => {
          const node = element.shadowRoot.querySelector('.param-name');
          assert.ok(node);
        });

        test('Renders value input', () => {
          const node = element.shadowRoot.querySelector('.custom-wrapper api-property-form-item');
          assert.ok(node);
        });
      });

      suite('_updateHeaderDocs()', () => {
        let element;
        setup(function(done) {
          element = fixture('Custom');
          element.model = genModel();
          flush(() => done());
        });

        test('Does nothing when noDocs', () => {
          element.noDocs = true;
          element._updateHeaderDocs([]);

          assert.isTrue(element.model.hasDescription);
        });

        test('Does nothing when _nameSuggestionsOpened', () => {
          element._nameSuggestionsOpened = true;
          element._updateHeaderDocs([]);

          assert.isTrue(element.model.hasDescription);
        });

        test('Clears the description when __ownDescription flag', () => {
          element.model.__ownDescription = true;
          element._updateHeaderDocs([]);

          assert.isFalse(element.model.hasDescription);
          assert.isUndefined(element.model.description);
        });

        test('Won\'t clear the description when no __ownDescription flag', () => {
          element._updateHeaderDocs([]);

          assert.isTrue(element.model.hasDescription);
          assert.equal(element.model.description, 'test');
        });

        test('Updates description from suggestions', () => {
          element.model.hasDescription = false;
          element._updateHeaderDocs([{
            desc: 'updated-desc'
          }]);

          assert.isTrue(element.model.hasDescription);
          assert.equal(element.model.description, 'updated-desc');
        });

        test('Sets __ownDescription flag', () => {
          element.model.hasDescription = false;
          element._updateHeaderDocs([{
            desc: 'updated-desc'
          }]);

          assert.isTrue(element.model.__ownDescription);
        });
      });

      suite('_onHeaderValueSelected()', () => {
        let element;
        setup(function(done) {
          element = fixture('Custom');
          element.model = genModel();
          flush(() => done());
        });

        test('Sets new value', () => {
          element._onHeaderValueSelected({
            detail: {
              value: 'new-value'
            }
          });
          assert.equal(element.value, 'new-value');
        });
      });

      suite('_closeAutocomplete()', () => {
        let element;
        setup(function(done) {
          element = fixture('Custom');
          element.model = genModel();
          flush(() => done());
        });

        test('Does nothing when no _valueInput', () => {
          element._valueInput = undefined;
          element._closeAutocomplete();
          assert.isUndefined(element.__closingAutocomplete);
        });

        test('Does nothing when __closingAutocomplete is set', () => {
          element._valueInput = 'test';
          element.__closingAutocomplete = 1;
          element._closeAutocomplete();
          assert.equal(element.__closingAutocomplete, 1);
        });

        test('Sets __closingAutocomplete', () => {
          element._valueInput = 'test';
          element._closeAutocomplete();
          assert.isTrue(element.__closingAutocomplete);
        });

        test('Re-sets __closingAutocomplete', () => {
          element._valueInput = 'test';
          element._closeAutocomplete();
          setTimeout(() => {
            assert.isFalse(element.__closingAutocomplete);
          }, 251);
        });
      });
      a11ySuite('Basic');
    });
    </script>

  </body>
</html>
