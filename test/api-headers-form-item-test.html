<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
    <title>api-headers-form test</title>

    <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
    <script src="../../../mocha/mocha.js"></script>
    <script src="../../../chai/chai.js"></script>
    <script src="../../../wct-mocha/wct-mocha.js"></script>
    <script src="../../../sinon/pkg/sinon.js"></script>

    <script type="module" src="../api-headers-form-item.js"></script>
  </head>
  <body>
    <arc-definitions></arc-definitions>

    <test-fixture id="Basic">
      <template>
        <api-headers-form-item name="test-name" value="test-value"></api-headers-form-item>
      </template>
    </test-fixture>

    <test-fixture id="Required">
      <template>
        <api-headers-form-item name="test-name" required></api-headers-form-item>
      </template>
    </test-fixture>

    <test-fixture id="Custom">
      <template>
        <api-headers-form-item name="test-name" value="test-value" is-custom></api-headers-form-item>
      </template>
    </test-fixture>

    <test-fixture id="Narrow">
      <template>
        <api-headers-form-item name="test-name" value="test-value" narrow></api-headers-form-item>
      </template>
    </test-fixture>

    <test-fixture id="NoDocs">
      <template>
        <api-headers-form-item name="Content-type" value="test-value" no-docs></api-headers-form-item>
      </template>
    </test-fixture>

    <script type="module">
    import '../../../@advanced-rest-client/arc-definitions/arc-definitions.js';
    suite('api-headers-form-item', () => {
      function genModel(name) {
        name = name || 'test-name';
        return {
          binding: 'header',
          name: name,
          hasDescription: true,
          description: 'test',
          required: true,
          schema: {
            enabled: true,
            type: 'string',
            inputLabel: 'x-string',
            isEnum: false,
            isArray: false,
            isBool: false,
            inputType: 'text'
          },
          value: 'test-value'
        };
      }


      suite('Basic tests', function() {
        let element;
        setup(function(done) {
          element = fixture('Basic');
          element.model = genModel();
          flush(() => done());
        });

        test('Renders form field for API defined item', () => {
          const node = element.shadowRoot.querySelector('.api-field');
          assert.ok(node);
        });

        test('Renders documentation toggle icon', () => {
          const node = element.shadowRoot.querySelector('.hint-icon');
          assert.ok(node);
        });

        test('Renders docs section', (done) => {
          element.toggleDocs();
          flush(() => {
            const node = element.shadowRoot.querySelector('.docs');
            assert.ok(node);
            done();
          });
        });

        test('Sets _valueInput on input focus', function() {
          element._customChangeFocus();
          const input = element.shadowRoot.querySelector('api-property-form-item');
          // input.focus();
          assert.isTrue(element._valueInput === input);
        });

        test('Sets __customChangeFocus on input focus', function() {
          element._customChangeFocus();
          assert.isTrue(element.__customChangeFocus);
        });
      });

      suite('Required', function() {
        let element;
        setup(function() {
          element = fixture('Required');
          const m = genModel();
          m.value = '';
          element.model = m;
        });

        test('Does not validate the in put', (done) => {
          flush(() => {
            const result = element.validate();
            assert.isFalse(result);
            done();
          });
        });

        test('Sets invalid property', (done) => {
          flush(() => {
            element.validate();
            assert.isTrue(element.invalid);
            done();
          });
        });
      });

      suite('Custom value', () => {
        let element;
        setup(function(done) {
          element = fixture('Custom');
          element.model = genModel();
          flush(() => done());
        });

        test('Renders custom section', () => {
          const node = element.shadowRoot.querySelector('.custom-wrapper');
          assert.ok(node);
        });

        test('Renders name input', () => {
          const node = element.shadowRoot.querySelector('.param-name');
          assert.ok(node);
        });

        test('Renders value input', () => {
          const node = element.shadowRoot.querySelector('.custom-wrapper api-property-form-item');
          assert.ok(node);
        });
      });

      suite('_updateHeaderDocs()', () => {
        let element;
        setup(function(done) {
          element = fixture('Custom');
          element.model = genModel();
          flush(() => done());
        });

        test('Does nothing when noDocs', () => {
          element.noDocs = true;
          element._updateHeaderDocs([]);

          assert.isTrue(element.model.hasDescription);
        });

        test('Does nothing when _nameSuggestionsOpened', () => {
          element._nameSuggestionsOpened = true;
          element._updateHeaderDocs([]);

          assert.isTrue(element.model.hasDescription);
        });

        test('Clears the description when __ownDescription flag', () => {
          element.model.__ownDescription = true;
          element._updateHeaderDocs([]);

          assert.isFalse(element.model.hasDescription);
          assert.isUndefined(element.model.description);
        });

        test('Won\'t clear the description when no __ownDescription flag', () => {
          element._updateHeaderDocs([]);

          assert.isTrue(element.model.hasDescription);
          assert.equal(element.model.description, 'test');
        });

        test('Updates description from suggestions', () => {
          element.model.hasDescription = false;
          element._updateHeaderDocs([{
            desc: 'updated-desc'
          }]);

          assert.isTrue(element.model.hasDescription);
          assert.equal(element.model.description, 'updated-desc');
        });

        test('Sets __ownDescription flag', () => {
          element.model.hasDescription = false;
          element._updateHeaderDocs([{
            desc: 'updated-desc'
          }]);

          assert.isTrue(element.model.__ownDescription);
        });
      });

      suite('_onHeaderValueSelected()', () => {
        let element;
        setup(function(done) {
          element = fixture('Custom');
          element.model = genModel();
          flush(() => done());
        });

        test('Sets new value', () => {
          element._onHeaderValueSelected({
            detail: {
              value: 'new-value'
            }
          });
          assert.equal(element.value, 'new-value');
        });
      });

      suite('_closeAutocomplete()', () => {
        let element;
        setup(function(done) {
          element = fixture('Custom');
          element.model = genModel();
          flush(() => done());
        });

        test('Does nothing when no _valueInput', () => {
          element._valueInput = undefined;
          element._closeAutocomplete();
          assert.isUndefined(element.__closingAutocomplete);
        });

        test('Does nothing when __closingAutocomplete is set', () => {
          element._valueInput = 'test';
          element.__closingAutocomplete = 1;
          element._closeAutocomplete();
          assert.equal(element.__closingAutocomplete, 1);
        });

        test('Sets __closingAutocomplete', () => {
          element._valueInput = 'test';
          element._closeAutocomplete();
          assert.isTrue(element.__closingAutocomplete);
        });

        test('Re-sets __closingAutocomplete', () => {
          element._valueInput = 'test';
          element._closeAutocomplete();
          setTimeout(() => {
            assert.isFalse(element.__closingAutocomplete);
          }, 251);
        });
      });

      suite('_docsAnimated()', () => {
        let element;
        setup(function(done) {
          element = fixture('Basic');
          element.model = genModel();
          flush(() => done());
        });

        test('Change in docsOpened calls _docsAnimated()', (done) => {
          const spy = sinon.spy(element, '_docsAnimated');
          element.toggleDocs();
          setTimeout(() => {
            assert.isTrue(spy.called);
            done();
          }, 360);
        });

        test('Toggle "if" on the template', (done) => {
          element.toggleDocs();
          setTimeout(() => {
            element.toggleDocs();
            setTimeout(() => {
              assert.isFalse(element.$.docsIf.if);
              done();
            }, 360);
          }, 360);
        });
      });

      suite('_headerNameFocus()', () => {
        let element;
        setup(function(done) {
          element = fixture('Basic');
          element.model = genModel();
          flush(() => done());
        });

        test('Does nothing when readonly', () => {
          element.readonly = true;
          element._headerNameFocus({target: 'test'});
          assert.isUndefined(element._nameInput);
        });

        test('Does nothing when _nameInput is set', () => {
          element._nameInput = 'test';
          element._headerNameFocus({target: 'other'});
          assert.equal(element._nameInput, 'test');
        });

        test('Sets value from currentTarget', () => {
          element._headerNameFocus({currentTarget: 'other'});
          assert.equal(element._nameInput, 'other');
        });

        test('Sets value from target', () => {
          element._headerNameFocus({target: 'other'});
          assert.equal(element._nameInput, 'other');
        });
      });

      suite('_onHeaderNameSelected()', () => {
        let element;
        setup(function() {
          element = fixture('Basic');
          element.model = genModel();
        });

        test('Sets name', () => {
          element._onHeaderNameSelected({
            detail: {
              value: 'test-value'
            }
          });
          assert.equal(element.name, 'test-value');
        });
      });

      suite('_queryHeaderName()', () => {
        let element;
        setup(function(done) {
          element = fixture('Basic');
          element.model = genModel();
          flush(() => done());
        });

        test('Calls _queryHeaderNameSuggestions()', () => {
          const spy = sinon.spy(element, '_queryHeaderNameSuggestions');
          element._queryHeaderName({
            detail: {
              value: 'test'
            }
          });
          assert.equal(spy.args[0][0], 'test');
        });

        test('Clean up when no suggestions', () => {
          element._nameSuggestions = [];
          element._nameSuggestionsOpened = true;
          element._queryHeaderName({
            detail: {
              value: 'no way to have a suggestion'
            }
          });
          assert.isUndefined(element._nameSuggestions);
          assert.isFalse(element._nameSuggestionsOpened);
        });

        test('Sets _nameSuggestions', () => {
          element._queryHeaderName({
            detail: {
              value: 'accept-encoding'
            }
          });
          assert.lengthOf(element._nameSuggestions, 1);
          assert.deepEqual(element._nameSuggestions, [{
            value: 'Accept-Encoding',
            display: 'Accept-Encoding'
          }]);
        });
      });
    });
    </script>

  </body>
</html>
